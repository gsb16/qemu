<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QEMU Object Model &mdash; QEMU 4.1.50 (v4.0.0-470-g250533e6-dirty) documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '4.1.50 (v4.0.0-470-g250533e6-dirty)',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="QEMU 4.1.50 (v4.0.0-470-g250533e6-dirty) documentation" href="../index.html" />
    <link rel="up" title="QOM headers" href="../qom.html" />
    <link rel="next" title="QEMU Object Model interfaces" href="object_interfaces.html" />
    <link rel="prev" title="QEMU CPU header" href="cpu.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="qemu-object-model">
<h1>QEMU Object Model<a class="headerlink" href="#qemu-object-model" title="Permalink to this headline">¶</a></h1>
<p>The documentation of QEMU&#8217;s Object Model header described in <code class="docutils literal"><span class="pre">qom/object.h</span></code> .</p>
<dl class="function">
<dt id="c.void">
typedef <code class="descname">void</code><span class="sig-paren">(</span>ObjectPropertyAccessor<span class="sig-paren">)</span><a class="headerlink" href="#c.void" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectPropertyAccessor</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>The QEMU Object Model provides a framework for registering user creatable
types and instantiating objects from those types.  QOM provides the following
features:</p>
<blockquote>
<div><ul class="simple">
<li>System for dynamically registering types</li>
<li>Support for single-inheritance of types</li>
<li>Multiple inheritance of stateless interfaces</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd>&lt;title&gt;Creating a minimal type&lt;/title&gt;
&lt;programlisting&gt;</dd>
</dl>
<p>#include &#8220;qdev.h&#8221;</p>
<p>#define TYPE_MY_DEVICE &#8220;my-device&#8221;</p>
<p>// No new virtual functions: we can reuse the typedef for the
// superclass.
typedef DeviceClass MyDeviceClass;
typedef struct MyDevice
{</p>
<blockquote>
<div><p>DeviceState parent;</p>
<p>int reg0, reg1, reg2;</p>
</div></blockquote>
<p>} MyDevice;</p>
<dl class="docutils">
<dt>static const TypeInfo my_device_info = {</dt>
<dd>.name = TYPE_MY_DEVICE,
.parent = TYPE_DEVICE,
.instance_size = sizeof(MyDevice),</dd>
</dl>
<p>};</p>
<p>static void my_device_register_types(void)
{</p>
<blockquote>
<div>type_register_static(<code class="xref c c-type docutils literal"><span class="pre">my_device_info</span></code>);</div></blockquote>
<p>}</p>
<dl class="docutils">
<dt>type_init(my_device_register_types)</dt>
<dd>&lt;/programlisting&gt;</dd>
</dl>
<p>&lt;/example&gt;</p>
<p>In the above example, we create a simple type that is described by #TypeInfo.
#TypeInfo describes information about the type including what it inherits
from, the instance and class size, and constructor/destructor hooks.</p>
<p>Alternatively several static types could be registered using helper macro
DEFINE_TYPES()</p>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd>&lt;programlisting&gt;</dd>
<dt>static const TypeInfo device_types_info[] = {</dt>
<dd><dl class="first docutils">
<dt>{</dt>
<dd>.name = TYPE_MY_DEVICE_A,
.parent = TYPE_DEVICE,
.instance_size = sizeof(MyDeviceA),</dd>
</dl>
<p>},
{</p>
<blockquote>
<div>.name = TYPE_MY_DEVICE_B,
.parent = TYPE_DEVICE,
.instance_size = sizeof(MyDeviceB),</div></blockquote>
<p class="last">},</p>
</dd>
</dl>
<p>};</p>
<dl class="docutils">
<dt>DEFINE_TYPES(device_types_info)</dt>
<dd>&lt;/programlisting&gt;</dd>
</dl>
<p>&lt;/example&gt;</p>
<p>Every type has an #ObjectClass associated with it.  #ObjectClass derivatives
are instantiated dynamically but there is only ever one instance for any
given type.  The #ObjectClass typically holds a table of function pointers
for the virtual methods implemented by this type.</p>
<p>Using object_new(), a new #Object derivative will be instantiated.  You can
cast an #Object to a subclass (or base-class) type using
object_dynamic_cast().  You typically want to define macro wrappers around
OBJECT_CHECK() and OBJECT_CLASS_CHECK() to make it easier to convert to a
specific type:</p>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd><p class="first">&lt;title&gt;Typecasting macros&lt;/title&gt;
&lt;programlisting&gt;</p>
<blockquote>
<div>#define MY_DEVICE_GET_CLASS(obj)  *       OBJECT_GET_CLASS(MyDeviceClass, obj, TYPE_MY_DEVICE)
#define MY_DEVICE_CLASS(klass)  *       OBJECT_CLASS_CHECK(MyDeviceClass, klass, TYPE_MY_DEVICE)
#define MY_DEVICE(obj)  *       OBJECT_CHECK(MyDevice, obj, TYPE_MY_DEVICE)</div></blockquote>
<p class="last">&lt;/programlisting&gt;</p>
</dd>
</dl>
<p>&lt;/example&gt;</p>
<p># Class Initialization #</p>
<p>Before an object is initialized, the class for the object must be
initialized.  There is only one class object for all instance objects
that is created lazily.</p>
<p>Classes are initialized by first initializing any parent classes (if
necessary).  After the parent class object has initialized, it will be
copied into the current class object and any additional storage in the
class object is zero filled.</p>
<p>The effect of this is that classes automatically inherit any virtual
function pointers that the parent class has already initialized.  All
other fields will be zero filled.</p>
<p>Once all of the parent classes have been initialized, #TypeInfo::class_init
is called to let the class being instantiated provide default initialize for
its virtual functions.  Here is how the above example might be modified
to introduce an overridden virtual function:</p>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd>&lt;title&gt;Overriding a virtual function&lt;/title&gt;
&lt;programlisting&gt;</dd>
</dl>
<p>#include &#8220;qdev.h&#8221;</p>
<p>void my_device_class_init(ObjectClass <a href="#id1"><span class="problematic" id="id2">*</span></a>klass, void <a href="#id3"><span class="problematic" id="id4">*</span></a>class_data)
{</p>
<blockquote>
<div>DeviceClass <a href="#id5"><span class="problematic" id="id6">*</span></a>dc = DEVICE_CLASS(klass);
dc-&gt;reset = my_device_reset;</div></blockquote>
<p>}</p>
<dl class="docutils">
<dt>static const TypeInfo my_device_info = {</dt>
<dd>.name = TYPE_MY_DEVICE,
.parent = TYPE_DEVICE,
.instance_size = sizeof(MyDevice),
.class_init = my_device_class_init,</dd>
<dt>};</dt>
<dd>&lt;/programlisting&gt;</dd>
</dl>
<p>&lt;/example&gt;</p>
<p>Introducing new virtual methods requires a class to define its own
struct and to add a .class_size member to the #TypeInfo.  Each method
will also have a wrapper function to call it easily:</p>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd>&lt;title&gt;Defining an abstract class&lt;/title&gt;
&lt;programlisting&gt;</dd>
</dl>
<p>#include &#8220;qdev.h&#8221;</p>
<p>typedef struct MyDeviceClass
{</p>
<blockquote>
<div><p>DeviceClass parent;</p>
<p>void (<a href="#id7"><span class="problematic" id="id8">*</span></a>frobnicate) (MyDevice <a href="#id9"><span class="problematic" id="id10">*</span></a>obj);</p>
</div></blockquote>
<p>} MyDeviceClass;</p>
<dl class="docutils">
<dt>static const TypeInfo my_device_info = {</dt>
<dd>.name = TYPE_MY_DEVICE,
.parent = TYPE_DEVICE,
.instance_size = sizeof(MyDevice),
.abstract = true, // or set a default in my_device_class_init
.class_size = sizeof(MyDeviceClass),</dd>
</dl>
<p>};</p>
<p>void my_device_frobnicate(MyDevice <a href="#id11"><span class="problematic" id="id12">*</span></a>obj)
{</p>
<blockquote>
<div><p>MyDeviceClass <a href="#id13"><span class="problematic" id="id14">*</span></a>klass = MY_DEVICE_GET_CLASS(obj);</p>
<p>klass-&gt;frobnicate(obj);</p>
</div></blockquote>
<dl class="docutils">
<dt>}</dt>
<dd>&lt;/programlisting&gt;</dd>
</dl>
<p>&lt;/example&gt;</p>
<p># Interfaces #</p>
<p>Interfaces allow a limited form of multiple inheritance.  Instances are
similar to normal types except for the fact that are only defined by
their classes and never carry any state.  You can dynamically cast an object
to one of its #Interface types and vice versa.</p>
<p># Methods #</p>
<p>A &lt;emphasis&gt;method&lt;/emphasis&gt; is a function within the namespace scope of
a class. It usually operates on the object instance by passing it as a
strongly-typed first argument.
If it does not operate on an object instance, it is dubbed
&lt;emphasis&gt;class method&lt;/emphasis&gt;.</p>
<p>Methods cannot be overloaded. That is, the #ObjectClass and method name
uniquely identity the function to be called; the signature does not vary
except for trailing varargs.</p>
<p>Methods are always &lt;emphasis&gt;virtual&lt;/emphasis&gt;. Overriding a method in
#TypeInfo.class_init of a subclass leads to any user of the class obtained
via OBJECT_GET_CLASS() accessing the overridden function.
The original function is not automatically invoked. It is the responsibility
of the overriding class to determine whether and when to invoke the method
being overridden.</p>
<p>To invoke the method being overridden, the preferred solution is to store
the original value in the overriding class before overriding the method.
This corresponds to <a href="#id57"><span class="problematic" id="id58">|[ {super,base}.method(...) ]|</span></a> in Java and C#
respectively; this frees the overriding class from hardcoding its parent
class, which someone might choose to change at some point.</p>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd>&lt;title&gt;Overriding a virtual method&lt;/title&gt;
&lt;programlisting&gt;</dd>
</dl>
<p>typedef struct MyState MyState;</p>
<p>typedef void (<a href="#id15"><span class="problematic" id="id16">*</span></a>MyDoSomething)(MyState <a href="#id17"><span class="problematic" id="id18">*</span></a>obj);</p>
<dl class="docutils">
<dt>typedef struct MyClass {</dt>
<dd><p class="first">ObjectClass parent_class;</p>
<p class="last">MyDoSomething do_something;</p>
</dd>
</dl>
<p>} MyClass;</p>
<p>static void my_do_something(MyState <a href="#id19"><span class="problematic" id="id20">*</span></a>obj)
{</p>
<blockquote>
<div>// do something</div></blockquote>
<p>}</p>
<p>static void my_class_init(ObjectClass <a href="#id21"><span class="problematic" id="id22">*</span></a>oc, void <a href="#id23"><span class="problematic" id="id24">*</span></a>data)
{</p>
<blockquote>
<div><p>MyClass <a href="#id25"><span class="problematic" id="id26">*</span></a>mc = MY_CLASS(oc);</p>
<p>mc-&gt;do_something = my_do_something;</p>
</div></blockquote>
<p>}</p>
<dl class="docutils">
<dt>static const TypeInfo my_type_info = {</dt>
<dd>.name = TYPE_MY,
.parent = TYPE_OBJECT,
.instance_size = sizeof(MyState),
.class_size = sizeof(MyClass),
.class_init = my_class_init,</dd>
</dl>
<p>};</p>
<dl class="docutils">
<dt>typedef struct DerivedClass {</dt>
<dd><p class="first">MyClass parent_class;</p>
<p class="last">MyDoSomething parent_do_something;</p>
</dd>
</dl>
<p>} DerivedClass;</p>
<p>static void derived_do_something(MyState <a href="#id27"><span class="problematic" id="id28">*</span></a>obj)
{</p>
<blockquote>
<div><p>DerivedClass <a href="#id29"><span class="problematic" id="id30">*</span></a>dc = DERIVED_GET_CLASS(obj);</p>
<p>// do something here
dc-&gt;parent_do_something(obj);
// do something else here</p>
</div></blockquote>
<p>}</p>
<p>static void derived_class_init(ObjectClass <a href="#id31"><span class="problematic" id="id32">*</span></a>oc, void <a href="#id33"><span class="problematic" id="id34">*</span></a>data)
{</p>
<blockquote>
<div><p>MyClass <a href="#id35"><span class="problematic" id="id36">*</span></a>mc = MY_CLASS(oc);
DerivedClass <a href="#id37"><span class="problematic" id="id38">*</span></a>dc = DERIVED_CLASS(oc);</p>
<p>dc-&gt;parent_do_something = mc-&gt;do_something;
mc-&gt;do_something = derived_do_something;</p>
</div></blockquote>
<p>}</p>
<dl class="docutils">
<dt>static const TypeInfo derived_type_info = {</dt>
<dd>.name = TYPE_DERIVED,
.parent = TYPE_MY,
.class_size = sizeof(DerivedClass),
.class_init = derived_class_init,</dd>
<dt>};</dt>
<dd>&lt;/programlisting&gt;</dd>
</dl>
<p>&lt;/example&gt;</p>
<p>Alternatively, object_class_by_name() can be used to obtain the class and
its non-overridden methods for a specific type. This would correspond to
<a href="#id59"><span class="problematic" id="id60">|[ MyClass::method(...) ]|</span></a> in C++.</p>
<p>The first example of such a QOM method was #CPUClass.reset,
another example is #DeviceClass.realize.</p>
<dl class="function">
<dt>
typedef <code class="descname">void</code><span class="sig-paren">(</span>ObjectPropertyRelease<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectPropertyRelease</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when a property is removed from a object.</p>
<dl class="function">
<dt>
typedef <code class="descname">void</code><span class="sig-paren">(</span>ObjectUnparent<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectUnparent</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when an object is being removed from the QOM composition tree.
The function should remove any backlinks from children objects to <strong>obj</strong>.</p>
<dl class="function">
<dt>
typedef <code class="descname">void</code><span class="sig-paren">(</span>ObjectFree<span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectFree</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when an object&#8217;s last reference is removed.</p>
<dl class="function">
<dt id="c.OBJECT">
<code class="descname">OBJECT</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span><a class="headerlink" href="#c.OBJECT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd>A derivative of #Object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts an object to a #Object.  Since all objects are #Objects,
this function will always succeed.</p>
<dl class="function">
<dt id="c.OBJECT_CLASS">
<code class="descname">OBJECT_CLASS</code><span class="sig-paren">(</span>class<span class="sig-paren">)</span><a class="headerlink" href="#c.OBJECT_CLASS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">class</span></code></dt>
<dd>A derivative of #ObjectClass.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts a class to an #ObjectClass.  Since all objects are #Objects,
this function will always succeed.</p>
<dl class="function">
<dt id="c.OBJECT_CHECK">
<code class="descname">OBJECT_CHECK</code><span class="sig-paren">(</span>type, obj, name<span class="sig-paren">)</span><a class="headerlink" href="#c.OBJECT_CHECK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>The C type to use for the return value.</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd>A derivative of <strong>type</strong> to cast.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>The QOM typename of <strong>type</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>A type safe version of <strong>object_dynamic_cast_assert</strong>.  Typically each class
will define a macro based on this type to perform type safe dynamic_casts to
this object type.</p>
<p>If an invalid object is passed to this function, a run time assert will be
generated.</p>
<dl class="function">
<dt id="c.OBJECT_CLASS_CHECK">
<code class="descname">OBJECT_CLASS_CHECK</code><span class="sig-paren">(</span>class_type, class, name<span class="sig-paren">)</span><a class="headerlink" href="#c.OBJECT_CLASS_CHECK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">class_type</span></code></dt>
<dd>The C type to use for the return value.</dd>
<dt><code class="docutils literal"><span class="pre">class</span></code></dt>
<dd>A derivative class of <strong>class_type</strong> to cast.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>the QOM typename of <strong>class_type</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A type safe version of <strong>object_class_dynamic_cast_assert</strong>.  This macro is
typically wrapped by each type to perform type safe casts of a class to a
specific class type.</p>
<dl class="function">
<dt id="c.OBJECT_GET_CLASS">
<code class="descname">OBJECT_GET_CLASS</code><span class="sig-paren">(</span>class, obj, name<span class="sig-paren">)</span><a class="headerlink" href="#c.OBJECT_GET_CLASS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">class</span></code></dt>
<dd>The C type to use for the return value.</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd>The object to obtain the class for.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>The QOM typename of <strong>obj</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return a specific class for a given object.  Its generally
used by each type to provide a type safe macro to get a specific class type
from an object.</p>
<dl class="function">
<dt id="c.INTERFACE_CLASS">
<code class="descname">INTERFACE_CLASS</code><span class="sig-paren">(</span>klass<span class="sig-paren">)</span><a class="headerlink" href="#c.INTERFACE_CLASS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">klass</span></code></dt>
<dd>class to cast from</dd>
</dl>
<p><strong>Return</strong></p>
<p>An #InterfaceClass or raise an error if cast is invalid</p>
<dl class="function">
<dt id="c.INTERFACE_CHECK">
<code class="descname">INTERFACE_CHECK</code><span class="sig-paren">(</span>interface, obj, name<span class="sig-paren">)</span><a class="headerlink" href="#c.INTERFACE_CHECK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">interface</span></code></dt>
<dd>the type to return</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd>the object to convert to an interface</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>the interface type name</dd>
</dl>
<p><strong>Return</strong></p>
<p><strong>obj</strong> casted to <strong>interface</strong> if cast is valid, otherwise raise error.</p>
<dl class="function">
<dt id="c.object_new">
Object * <code class="descname">object_new</code><span class="sig-paren">(</span>const char *<em>&nbsp;typename</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_new" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>The name of the type of the object to instantiate.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will initialize a new object using heap allocated memory.
The returned object has a reference count of 1, and will be freed when
the last reference is dropped.</p>
<p><strong>Return</strong></p>
<p>The newly allocated and instantiated object.</p>
<dl class="function">
<dt id="c.object_new_with_props">
Object * <code class="descname">object_new_with_props</code><span class="sig-paren">(</span>const char *<em>&nbsp;typename</em>, Object *<em>&nbsp;parent</em>, const char *<em>&nbsp;id</em>, Error **<em>&nbsp;errp</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.object_new_with_props" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>The name of the type of the object to instantiate.</dd>
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the parent object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>The unique ID of the object</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>pointer to error object</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>list of property names and values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will initialize a new object using heap allocated memory.
The returned object has a reference count of 1, and will be freed when
the last reference is dropped.</p>
<p>The <strong>id</strong> parameter will be used when registering the object as a
child of <strong>parent</strong> in the composition tree.</p>
<p>The variadic parameters are a list of pairs of (propname, propvalue)
strings. The propname of <code class="docutils literal"><span class="pre">NULL</span></code> indicates the end of the property
list. If the object implements the user creatable interface, the
object will be marked complete once all the properties have been
processed.</p>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd><p class="first">&lt;title&gt;Creating an object with properties&lt;/title&gt;
&lt;programlisting&gt;
Error <a href="#id39"><span class="problematic" id="id40">*</span></a>err = NULL;
Object <a href="#id41"><span class="problematic" id="id42">*</span></a>obj;</p>
<dl class="docutils">
<dt>obj = object_new_with_props(TYPE_MEMORY_BACKEND_FILE,</dt>
<dd>object_get_objects_root(),
&#8220;hostmem0&#8221;,
<code class="xref c c-type docutils literal"><span class="pre">err</span></code>,
&#8220;share&#8221;, &#8220;yes&#8221;,
&#8220;mem-path&#8221;, &#8220;/dev/shm/somefile&#8221;,
&#8220;prealloc&#8221;, &#8220;yes&#8221;,
&#8220;size&#8221;, &#8220;1048576&#8221;,
NULL);</dd>
<dt>if (!obj) {</dt>
<dd><dl class="first last docutils">
<dt>g_printerr(&#8220;Cannot create memory backend: <code class="docutils literal"><span class="pre">s</span></code>n&#8221;,</dt>
<dd>error_get_pretty(err));</dd>
</dl>
</dd>
</dl>
<p class="last">}
&lt;/programlisting&gt;</p>
</dd>
</dl>
<p>&lt;/example&gt;</p>
<p>The returned object will have one stable reference maintained
for as long as it is present in the object hierarchy.</p>
<p><strong>Return</strong></p>
<p>The newly allocated, instantiated &amp; initialized object.</p>
<dl class="function">
<dt id="c.object_new_with_propv">
Object * <code class="descname">object_new_with_propv</code><span class="sig-paren">(</span>const char *<em>&nbsp;typename</em>, Object *<em>&nbsp;parent</em>, const char *<em>&nbsp;id</em>, Error **<em>&nbsp;errp</em>, va_list<em>&nbsp;vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_new_with_propv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>The name of the type of the object to instantiate.</dd>
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the parent object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>The unique ID of the object</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>pointer to error object</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">vargs</span></code></dt>
<dd>list of property names and values</dd>
</dl>
<p><strong>Description</strong></p>
<p>See object_new_with_props() for documentation.</p>
<dl class="function">
<dt id="c.object_set_props">
int <code class="descname">object_set_props</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, Error **<em>&nbsp;errp</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.object_set_props" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object instance to set properties on</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>pointer to error object</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>list of property names and values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will set a list of properties on an existing object
instance.</p>
<p>The variadic parameters are a list of pairs of (propname, propvalue)
strings. The propname of <code class="docutils literal"><span class="pre">NULL</span></code> indicates the end of the property
list.</p>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd><p class="first">&lt;title&gt;Update an object&#8217;s properties&lt;/title&gt;
&lt;programlisting&gt;
Error <a href="#id43"><span class="problematic" id="id44">*</span></a>err = NULL;
Object <a href="#id45"><span class="problematic" id="id46">*</span></a>obj = ...get / create object...;</p>
<dl class="docutils">
<dt>obj = object_set_props(obj,</dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">err</span></code>,
&#8220;share&#8221;, &#8220;yes&#8221;,
&#8220;mem-path&#8221;, &#8220;/dev/shm/somefile&#8221;,
&#8220;prealloc&#8221;, &#8220;yes&#8221;,
&#8220;size&#8221;, &#8220;1048576&#8221;,
NULL);</dd>
<dt>if (!obj) {</dt>
<dd><dl class="first last docutils">
<dt>g_printerr(&#8220;Cannot set properties: <code class="docutils literal"><span class="pre">s</span></code>n&#8221;,</dt>
<dd>error_get_pretty(err));</dd>
</dl>
</dd>
</dl>
<p class="last">}
&lt;/programlisting&gt;</p>
</dd>
</dl>
<p>&lt;/example&gt;</p>
<p>The returned object will have one stable reference maintained
for as long as it is present in the object hierarchy.</p>
<p><strong>Return</strong></p>
<p>-1 on error, 0 on success</p>
<dl class="function">
<dt id="c.object_set_propv">
int <code class="descname">object_set_propv</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, Error **<em>&nbsp;errp</em>, va_list<em>&nbsp;vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_set_propv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object instance to set properties on</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>pointer to error object</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">vargs</span></code></dt>
<dd>list of property names and values</dd>
</dl>
<p><strong>Description</strong></p>
<p>See object_set_props() for documentation.</p>
<p><strong>Return</strong></p>
<p>-1 on error, 0 on success</p>
<dl class="function">
<dt id="c.object_initialize">
void <code class="descname">object_initialize</code><span class="sig-paren">(</span>void *<em>&nbsp;obj</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;typename</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>A pointer to the memory to be used for the object.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The maximum size available at <strong>obj</strong> for the object.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>The name of the type of the object to instantiate.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will initialize an object.  The memory for the object should
have already been allocated.  The returned object has a reference count of 1,
and will be finalized when the last reference is dropped.</p>
<dl class="function">
<dt id="c.object_initialize_child">
void <code class="descname">object_initialize_child</code><span class="sig-paren">(</span>Object *<em>&nbsp;parentobj</em>, const char *<em>&nbsp;propname</em>, void *<em>&nbsp;childobj</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;type</em>, Error **<em>&nbsp;errp</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.object_initialize_child" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">parentobj</span></code></dt>
<dd>The parent object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">propname</span></code></dt>
<dd>The name of the property</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">childobj</span></code></dt>
<dd>A pointer to the memory to be used for the object.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The maximum size available at <strong>childobj</strong> for the object.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>The name of the type of the object to instantiate.</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>If an error occurs, a pointer to an area to store the error</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>list of property names and values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will initialize an object. The memory for the object should
have already been allocated. The object will then be added as child property
to a parent with object_property_add_child() function. The returned object
has a reference count of 1 (for the &#8220;child&lt;...&gt;&#8221; property from the parent),
so the object will be finalized automatically when the parent gets removed.</p>
<p>The variadic parameters are a list of pairs of (propname, propvalue)
strings. The propname of <code class="docutils literal"><span class="pre">NULL</span></code> indicates the end of the property list.
If the object implements the user creatable interface, the object will
be marked complete once all the properties have been processed.</p>
<dl class="function">
<dt id="c.object_initialize_childv">
void <code class="descname">object_initialize_childv</code><span class="sig-paren">(</span>Object *<em>&nbsp;parentobj</em>, const char *<em>&nbsp;propname</em>, void *<em>&nbsp;childobj</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;type</em>, Error **<em>&nbsp;errp</em>, va_list<em>&nbsp;vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_initialize_childv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">parentobj</span></code></dt>
<dd>The parent object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">propname</span></code></dt>
<dd>The name of the property</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">childobj</span></code></dt>
<dd>A pointer to the memory to be used for the object.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The maximum size available at <strong>childobj</strong> for the object.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>The name of the type of the object to instantiate.</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>If an error occurs, a pointer to an area to store the error</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">vargs</span></code></dt>
<dd>list of property names and values</dd>
</dl>
<p><strong>Description</strong></p>
<p>See object_initialize_child() for documentation.</p>
<dl class="function">
<dt id="c.object_dynamic_cast">
Object * <code class="descname">object_dynamic_cast</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;typename</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_dynamic_cast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>The object to cast.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>The <strong>typename</strong> to cast to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will determine if <strong>obj</strong> is-a <strong>typename</strong>.  <strong>obj</strong> can refer to an
object or an interface associated with an object.</p>
<p><strong>Return</strong></p>
<p>This function returns <strong>obj</strong> on success or #NULL on failure.</p>
<dl class="function">
<dt id="c.object_dynamic_cast_assert">
Object * <code class="descname">object_dynamic_cast_assert</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;typename</em>, const char *<em>&nbsp;file</em>, int<em>&nbsp;line</em>, const char *<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_dynamic_cast_assert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">line</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">func</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>See object_dynamic_cast() for a description of the parameters of this
function.  The only difference in behavior is that this function asserts
instead of returning #NULL on failure if QOM cast debugging is enabled.
This function is not meant to be called directly, but only through
the wrapper macro OBJECT_CHECK.</p>
<dl class="function">
<dt id="c.object_get_class">
ObjectClass * <code class="descname">object_get_class</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_get_class" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>A derivative of #Object</dd>
</dl>
<p><strong>Return</strong></p>
<p>The #ObjectClass of the type associated with <strong>obj</strong>.</p>
<dl class="function">
<dt id="c.object_get_typename">
const char * <code class="descname">object_get_typename</code><span class="sig-paren">(</span>const Object *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_get_typename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>A derivative of #Object.</dd>
</dl>
<p><strong>Return</strong></p>
<p>The QOM typename of <strong>obj</strong>.</p>
<dl class="function">
<dt id="c.type_register_static">
Type <code class="descname">type_register_static</code><span class="sig-paren">(</span>const TypeInfo *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.type_register_static" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">TypeInfo</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>The #TypeInfo of the new type.</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>info</strong> and all of the strings it points to should exist for the life time
that the type is registered.</p>
<p><strong>Return</strong></p>
<p>the new #Type.</p>
<dl class="function">
<dt id="c.type_register">
Type <code class="descname">type_register</code><span class="sig-paren">(</span>const TypeInfo *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.type_register" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">TypeInfo</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>The #TypeInfo of the new type</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike type_register_static(), this call does not require <strong>info</strong> or its
string members to continue to exist after the call returns.</p>
<p><strong>Return</strong></p>
<p>the new #Type.</p>
<dl class="function">
<dt id="c.type_register_static_array">
void <code class="descname">type_register_static_array</code><span class="sig-paren">(</span>const TypeInfo *<em>&nbsp;infos</em>, int<em>&nbsp;nr_infos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.type_register_static_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">TypeInfo</span> <span class="pre">*</span> <span class="pre">infos</span></code></dt>
<dd>The array of the new type #TypeInfo structures.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_infos</span></code></dt>
<dd>number of entries in <strong>infos</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>infos</strong> and all of the strings it points to should exist for the life time
that the type is registered.</p>
<dl class="function">
<dt id="c.DEFINE_TYPES">
<code class="descname">DEFINE_TYPES</code><span class="sig-paren">(</span>type_array<span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_TYPES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type_array</span></code></dt>
<dd>The array containing #TypeInfo structures to register</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>type_array</strong> should be static constant that exists for the life time
that the type is registered.</p>
<dl class="function">
<dt id="c.object_class_dynamic_cast_assert">
ObjectClass * <code class="descname">object_class_dynamic_cast_assert</code><span class="sig-paren">(</span>ObjectClass *<em>&nbsp;klass</em>, const char *<em>&nbsp;typename</em>, const char *<em>&nbsp;file</em>, int<em>&nbsp;line</em>, const char *<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_dynamic_cast_assert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectClass</span> <span class="pre">*</span> <span class="pre">klass</span></code></dt>
<dd>The #ObjectClass to attempt to cast.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>The QOM typename of the class to cast to.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">line</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">func</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>See object_class_dynamic_cast() for a description of the parameters
of this function.  The only difference in behavior is that this function
asserts instead of returning #NULL on failure if QOM cast debugging is
enabled.  This function is not meant to be called directly, but only through
the wrapper macros OBJECT_CLASS_CHECK and INTERFACE_CHECK.</p>
<dl class="function">
<dt id="c.object_class_dynamic_cast">
ObjectClass * <code class="descname">object_class_dynamic_cast</code><span class="sig-paren">(</span>ObjectClass *<em>&nbsp;klass</em>, const char *<em>&nbsp;typename</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_dynamic_cast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectClass</span> <span class="pre">*</span> <span class="pre">klass</span></code></dt>
<dd>The #ObjectClass to attempt to cast.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>The QOM typename of the class to cast to.</dd>
</dl>
<p><strong>Return</strong></p>
<p>If <strong>typename</strong> is a class, this function returns <strong>klass</strong> if
<strong>typename</strong> is a subtype of <strong>klass</strong>, else returns #NULL.</p>
<p>If <strong>typename</strong> is an interface, this function returns the interface
definition for <strong>klass</strong> if <strong>klass</strong> implements it unambiguously; #NULL
is returned if <strong>klass</strong> does not implement the interface or if multiple
classes or interfaces on the hierarchy leading to <strong>klass</strong> implement
it.  (FIXME: perhaps this can be detected at type definition time?)</p>
<dl class="function">
<dt id="c.object_class_get_parent">
ObjectClass * <code class="descname">object_class_get_parent</code><span class="sig-paren">(</span>ObjectClass *<em>&nbsp;klass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_get_parent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectClass</span> <span class="pre">*</span> <span class="pre">klass</span></code></dt>
<dd>The class to obtain the parent for.</dd>
</dl>
<p><strong>Return</strong></p>
<p>The parent for <strong>klass</strong> or <code class="docutils literal"><span class="pre">NULL</span></code> if none.</p>
<dl class="function">
<dt id="c.object_class_get_name">
const char * <code class="descname">object_class_get_name</code><span class="sig-paren">(</span>ObjectClass *<em>&nbsp;klass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_get_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectClass</span> <span class="pre">*</span> <span class="pre">klass</span></code></dt>
<dd>The class to obtain the QOM typename for.</dd>
</dl>
<p><strong>Return</strong></p>
<p>The QOM typename for <strong>klass</strong>.</p>
<dl class="function">
<dt id="c.object_class_is_abstract">
<a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a> <code class="descname">object_class_is_abstract</code><span class="sig-paren">(</span>ObjectClass *<em>&nbsp;klass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_is_abstract" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectClass</span> <span class="pre">*</span> <span class="pre">klass</span></code></dt>
<dd>The class to obtain the abstractness for.</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>klass</strong> is abstract, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.object_class_by_name">
ObjectClass * <code class="descname">object_class_by_name</code><span class="sig-paren">(</span>const char *<em>&nbsp;typename</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_by_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>The QOM typename to obtain the class for.</dd>
</dl>
<p><strong>Return</strong></p>
<p>The class for <strong>typename</strong> or <code class="docutils literal"><span class="pre">NULL</span></code> if not found.</p>
<dl class="function">
<dt id="c.object_class_get_list">
GSList * <code class="descname">object_class_get_list</code><span class="sig-paren">(</span>const char *<em>&nbsp;implements_type</em>, <a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a><em>&nbsp;include_abstract</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_get_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">implements_type</span></code></dt>
<dd>The type to filter for, including its derivatives.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">include_abstract</span></code></dt>
<dd>Whether to include abstract classes.</dd>
</dl>
<p><strong>Return</strong></p>
<p>A singly-linked list of the classes in reverse hashtable order.</p>
<dl class="function">
<dt id="c.object_class_get_list_sorted">
GSList * <code class="descname">object_class_get_list_sorted</code><span class="sig-paren">(</span>const char *<em>&nbsp;implements_type</em>, <a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a><em>&nbsp;include_abstract</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_get_list_sorted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">implements_type</span></code></dt>
<dd>The type to filter for, including its derivatives.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">include_abstract</span></code></dt>
<dd>Whether to include abstract classes.</dd>
</dl>
<p><strong>Return</strong></p>
<p>A singly-linked list of the classes in alphabetical
case-insensitive order.</p>
<dl class="function">
<dt id="c.object_ref">
void <code class="descname">object_ref</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_ref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increase the reference count of a object.  A object cannot be freed as long
as its reference count is greater than zero.</p>
<dl class="function">
<dt id="c.object_unref">
void <code class="descname">object_unref</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_unref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrease the reference count of a object.  A object cannot be freed as long
as its reference count is greater than zero.</p>
<dl class="function">
<dt id="c.object_property_add">
ObjectProperty * <code class="descname">object_property_add</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const char *<em>&nbsp;type</em>, ObjectPropertyAccessor *<em>&nbsp;get</em>, ObjectPropertyAccessor *<em>&nbsp;set</em>, ObjectPropertyRelease *<em>&nbsp;release</em>, void *<em>&nbsp;opaque</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property.  This can contain any character except for
a forward slash.  In general, you should use hyphens &#8216;-&#8216; instead of
underscores &#8216;_&#8217; when naming properties.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>the type name of the property.  This namespace is pretty loosely
defined.  Sub namespaces are constructed by using a prefix and then
to angle brackets.  For instance, the type &#8216;virtio-net-pci&#8217; in the
&#8216;link&#8217; namespace would be &#8216;link&lt;virtio-net-pci&gt;&#8217;.</dd>
<dt><code class="docutils literal"><span class="pre">ObjectPropertyAccessor</span> <span class="pre">*</span> <span class="pre">get</span></code></dt>
<dd>The getter to be called to read a property.  If this is NULL, then
the property cannot be read.</dd>
<dt><code class="docutils literal"><span class="pre">ObjectPropertyAccessor</span> <span class="pre">*</span> <span class="pre">set</span></code></dt>
<dd>the setter to be called to write a property.  If this is NULL,
then the property cannot be written.</dd>
<dt><code class="docutils literal"><span class="pre">ObjectPropertyRelease</span> <span class="pre">*</span> <span class="pre">release</span></code></dt>
<dd>called when the property is removed from the object.  This is
meant to allow a property to free its opaque upon object
destruction.  This may be NULL.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">opaque</span></code></dt>
<dd>an opaque pointer to pass to the callbacks for the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>The #ObjectProperty; this can be used to set the <strong>resolve</strong>
callback for child and link properties.</p>
<dl class="function">
<dt id="c.object_property_find">
ObjectProperty * <code class="descname">object_property_find</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_find" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look up a property for an object and return its #ObjectProperty if found.</p>
<dl class="function">
<dt id="c.object_property_iter_init">
void <code class="descname">object_property_iter_init</code><span class="sig-paren">(</span>ObjectPropertyIterator *<em>&nbsp;iter</em>, Object *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_iter_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectPropertyIterator</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes an iterator for traversing all properties
registered against an object instance, its class and all parent classes.</p>
<p>It is forbidden to modify the property list while iterating,
whether removing or adding properties.</p>
<p>Typical usage pattern would be</p>
<dl class="docutils">
<dt>&lt;example&gt;</dt>
<dd><p class="first">&lt;title&gt;Using object property iterators&lt;/title&gt;
&lt;programlisting&gt;
ObjectProperty <a href="#id47"><span class="problematic" id="id48">*</span></a>prop;
ObjectPropertyIterator iter;</p>
<p>object_property_iter_init(<code class="xref c c-type docutils literal"><span class="pre">iter</span></code>, obj);
while ((prop = object_property_iter_next(<code class="xref c c-type docutils literal"><span class="pre">iter</span></code>))) {</p>
<blockquote>
<div>... do something with prop ...</div></blockquote>
<p class="last">}
&lt;/programlisting&gt;</p>
</dd>
</dl>
<p>&lt;/example&gt;</p>
<dl class="function">
<dt id="c.object_class_property_iter_init">
void <code class="descname">object_class_property_iter_init</code><span class="sig-paren">(</span>ObjectPropertyIterator *<em>&nbsp;iter</em>, ObjectClass *<em>&nbsp;klass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_class_property_iter_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectPropertyIterator</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">ObjectClass</span> <span class="pre">*</span> <span class="pre">klass</span></code></dt>
<dd>the class</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes an iterator for traversing all properties
registered against an object class and all parent classes.</p>
<p>It is forbidden to modify the property list while iterating,
whether removing or adding properties.</p>
<p>This can be used on abstract classes as it does not create a temporary
instance.</p>
<dl class="function">
<dt id="c.object_property_iter_next">
ObjectProperty * <code class="descname">object_property_iter_next</code><span class="sig-paren">(</span>ObjectPropertyIterator *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_iter_next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ObjectPropertyIterator</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>the iterator instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the next available property. If no further properties
are available, a <code class="docutils literal"><span class="pre">NULL</span></code> value will be returned and the <strong>iter</strong>
pointer should not be used again after this point without
re-initializing it.</p>
<p><strong>Return</strong></p>
<p>the next property, or <code class="docutils literal"><span class="pre">NULL</span></code> when all properties
have been traversed.</p>
<dl class="function">
<dt id="c.object_property_get">
void <code class="descname">object_property_get</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, Visitor *<em>&nbsp;v</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">Visitor</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>the visitor that will receive the property value.  This should be an
Output visitor and the data will be written with <strong>name</strong> as the name.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a property from a object.</p>
<dl class="function">
<dt id="c.object_property_set_str">
void <code class="descname">object_property_set_str</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;value</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_set_str" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>the value to be written to the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a string value to a property.</p>
<dl class="function">
<dt id="c.object_property_get_str">
char * <code class="descname">object_property_get_str</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get_str" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>the value of the property, converted to a C string, or NULL if
an error occurs (including when the property value is not a string).
The caller should free the string.</p>
<dl class="function">
<dt id="c.object_property_set_link">
void <code class="descname">object_property_set_link</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, Object *<em>&nbsp;value</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_set_link" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>the value to be written to the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes an object&#8217;s canonical path to a property.</p>
<p>If the link property was created with
&lt;code&gt;OBJ_PROP_LINK_STRONG&lt;/code&gt; bit, the old target object is
unreferenced, and a reference is added to the new target object.</p>
<dl class="function">
<dt id="c.object_property_get_link">
Object * <code class="descname">object_property_get_link</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get_link" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>the value of the property, resolved from a path to an Object,
or NULL if an error occurs (including when the property value is not a
string or not a valid object path).</p>
<dl class="function">
<dt id="c.object_property_set_bool">
void <code class="descname">object_property_set_bool</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, <a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a><em>&nbsp;value</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_set_bool" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">value</span></code></dt>
<dd>the value to be written to the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a bool value to a property.</p>
<dl class="function">
<dt id="c.object_property_get_bool">
<a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a> <code class="descname">object_property_get_bool</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get_bool" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>the value of the property, converted to a boolean, or NULL if
an error occurs (including when the property value is not a bool).</p>
<dl class="function">
<dt id="c.object_property_set_int">
void <code class="descname">object_property_set_int</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, int64_t<em>&nbsp;value</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_set_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">int64_t</span> <span class="pre">value</span></code></dt>
<dd>the value to be written to the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes an integer value to a property.</p>
<dl class="function">
<dt id="c.object_property_get_int">
int64_t <code class="descname">object_property_get_int</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>the value of the property, converted to an integer, or negative if
an error occurs (including when the property value is not an integer).</p>
<dl class="function">
<dt id="c.object_property_set_uint">
void <code class="descname">object_property_set_uint</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, uint64_t<em>&nbsp;value</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_set_uint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">value</span></code></dt>
<dd>the value to be written to the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes an unsigned integer value to a property.</p>
<dl class="function">
<dt id="c.object_property_get_uint">
uint64_t <code class="descname">object_property_get_uint</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get_uint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>the value of the property, converted to an unsigned integer, or 0
an error occurs (including when the property value is not an integer).</p>
<dl class="function">
<dt id="c.object_property_get_enum">
int <code class="descname">object_property_get_enum</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const char *<em>&nbsp;typename</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get_enum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>the name of the enum data type</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>the value of the property, converted to an integer, or
undefined if an error occurs (including when the property value is not
an enum).</p>
<dl class="function">
<dt id="c.object_property_get_uint16List">
void <code class="descname">object_property_get_uint16List</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, uint16List **<em>&nbsp;list</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get_uint16List" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">uint16List</span> <span class="pre">**</span> <span class="pre">list</span></code></dt>
<dd>the returned int list</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>the value of the property, converted to integers, or
undefined if an error occurs (including when the property value is not
an list of integers).</p>
<dl class="function">
<dt id="c.object_property_set">
void <code class="descname">object_property_set</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, Visitor *<em>&nbsp;v</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">Visitor</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>the visitor that will be used to write the property value.  This should
be an Input visitor and the data will be first read with <strong>name</strong> as the
name and then written as the property value.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a property to a object.</p>
<dl class="function">
<dt id="c.object_property_parse">
void <code class="descname">object_property_parse</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;string</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">string</span></code></dt>
<dd>the string that will be used to parse the property value.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses a string and writes the result into a property of an object.</p>
<dl class="function">
<dt id="c.object_property_print">
char * <code class="descname">object_property_print</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, <a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a><em>&nbsp;human</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_print" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">human</span></code></dt>
<dd>if true, print for human consumption</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a string representation of the value of the property.  The
caller shall free the string.</p>
<dl class="function">
<dt id="c.object_property_get_type">
const char * <code class="descname">object_property_get_type</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_get_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>returns an error if this function fails</dd>
</dl>
<p><strong>Return</strong></p>
<p>The type name of the property.</p>
<dl class="function">
<dt id="c.object_get_root">
Object * <code class="descname">object_get_root</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.object_get_root" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Return</strong></p>
<p>the root object of the composition tree</p>
<dl class="function">
<dt id="c.object_get_objects_root">
Object * <code class="descname">object_get_objects_root</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.object_get_objects_root" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the container object that holds user created
object instances. This is the object at path
&#8220;/objects&#8221;</p>
<p><strong>Return</strong></p>
<p>the user object container</p>
<dl class="function">
<dt id="c.object_get_internal_root">
Object * <code class="descname">object_get_internal_root</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.object_get_internal_root" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the container object that holds internally used object
instances.  Any object which is put into this container must not be
user visible, and it will not be exposed in the QOM tree.</p>
<p><strong>Return</strong></p>
<p>the internal object container</p>
<dl class="function">
<dt id="c.object_get_canonical_path_component">
gchar * <code class="descname">object_get_canonical_path_component</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_get_canonical_path_component" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Return</strong></p>
<p>The final component in the object&#8217;s canonical path.  The canonical
path is the path within the composition tree starting from the root.
<code class="docutils literal"><span class="pre">NULL</span></code> if the object doesn&#8217;t have a parent (and thus a canonical path).</p>
<dl class="function">
<dt id="c.object_get_canonical_path">
gchar * <code class="descname">object_get_canonical_path</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_get_canonical_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Return</strong></p>
<p>The canonical path for a object.  This is the path within the
composition tree starting from the root.</p>
<dl class="function">
<dt id="c.object_resolve_path">
Object * <code class="descname">object_resolve_path</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, <a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a> *<em>&nbsp;ambiguous</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_resolve_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>the path to resolve</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">ambiguous</span></code></dt>
<dd>returns true if the path resolution failed because of an
ambiguous match</dd>
</dl>
<p><strong>Description</strong></p>
<p>There are two types of supported paths&#8211;absolute paths and partial paths.</p>
<p>Absolute paths are derived from the root object and can follow child&lt;&gt; or
link&lt;&gt; properties.  Since they can follow link&lt;&gt; properties, they can be
arbitrarily long.  Absolute paths look like absolute filenames and are
prefixed with a leading slash.</p>
<p>Partial paths look like relative filenames.  They do not begin with a
prefix.  The matching rules for partial paths are subtle but designed to make
specifying objects easy.  At each level of the composition tree, the partial
path is matched as an absolute path.  The first match is not returned.  At
least two matches are searched for.  A successful result is only returned if
only one match is found.  If more than one match is found, a flag is
returned to indicate that the match was ambiguous.</p>
<p><strong>Return</strong></p>
<p>The matched object or NULL on path lookup failure.</p>
<dl class="function">
<dt id="c.object_resolve_path_type">
Object * <code class="descname">object_resolve_path_type</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, const char *<em>&nbsp;typename</em>, <a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a> *<em>&nbsp;ambiguous</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_resolve_path_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>the path to resolve</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>the type to look for.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">ambiguous</span></code></dt>
<dd>returns true if the path resolution failed because of an
ambiguous match</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to object_resolve_path.  However, when looking for a
partial path only matches that implement the given type are considered.
This restricts the search and avoids spuriously flagging matches as
ambiguous.</p>
<p>For both partial and absolute paths, the return value goes through
a dynamic cast to <strong>typename</strong>.  This is important if either the link,
or the typename itself are of interface types.</p>
<p><strong>Return</strong></p>
<p>The matched object or NULL on path lookup failure.</p>
<dl class="function">
<dt id="c.object_resolve_path_component">
Object * <code class="descname">object_resolve_path_component</code><span class="sig-paren">(</span>Object *<em>&nbsp;parent</em>, const gchar *<em>&nbsp;part</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_resolve_path_component" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the object in which to resolve the path</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">gchar</span> <span class="pre">*</span> <span class="pre">part</span></code></dt>
<dd>the component to resolve.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to object_resolve_path with an absolute path, but it
only resolves one element (<strong>part</strong>) and takes the others from <strong>parent</strong>.</p>
<p><strong>Return</strong></p>
<p>The resolved object or NULL on path lookup failure.</p>
<dl class="function">
<dt id="c.object_property_add_child">
void <code class="descname">object_property_add_child</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Object *<em>&nbsp;child</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_child" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">child</span></code></dt>
<dd>the child object</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Child properties form the composition tree.  All objects need to be a child
of another object.  Objects can only be a child of one object.</p>
<p>There is no way for a child to determine what its parent is.  It is not
a bidirectional relationship.  This is by design.</p>
<p>The value of a child property as a C string will be the child object&#8217;s
canonical path. It can be retrieved using object_property_get_str().
The child object itself can be retrieved using object_property_get_link().</p>
<dl class="function">
<dt id="c.object_property_allow_set_link">
void <code class="descname">object_property_allow_set_link</code><span class="sig-paren">(</span>Error<em>&nbsp;**</em>, Error<em>&nbsp;**</em>, Error<em>&nbsp;**</em>, Error<em>&nbsp;**</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_allow_set_link" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><a href="#id49"><span class="problematic" id="id50">``</span></a>Error ** ``</dt>
<dd><em>undescribed</em></dd>
<dt><a href="#id51"><span class="problematic" id="id52">``</span></a>Error ** ``</dt>
<dd><em>undescribed</em></dd>
<dt><a href="#id53"><span class="problematic" id="id54">``</span></a>Error ** ``</dt>
<dd><em>undescribed</em></dd>
<dt><a href="#id55"><span class="problematic" id="id56">``</span></a>Error ** ``</dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>The default implementation of the object_property_add_link() check()
callback function.  It allows the link property to be set and never returns
an error.</p>
<dl class="function">
<dt id="c.object_property_add_link">
void <code class="descname">object_property_add_link</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const char *<em>&nbsp;type</em>, Object **<em>&nbsp;child</em>, void (*check) (const Object<em>&nbsp;*obj</em>, const char<em>&nbsp;*name</em>, Object<em>&nbsp;*val</em>, Error<em>&nbsp;**errp</em>, ObjectPropertyLinkFlags<em>&nbsp;flags</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_link" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>the qobj type of the link</dd>
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">**</span> <span class="pre">child</span></code></dt>
<dd>a pointer to where the link object reference is stored</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(const</span> <span class="pre">Object</span> <span class="pre">*obj,</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name,</span> <span class="pre">Object</span> <span class="pre">*val,</span> <span class="pre">Error</span> <span class="pre">**errp)</span> <span class="pre">check</span></code></dt>
<dd>callback to veto setting or NULL if the property is read-only</dd>
<dt><code class="docutils literal"><span class="pre">ObjectPropertyLinkFlags</span> <span class="pre">flags</span></code></dt>
<dd>additional options for the link</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Links establish relationships between objects.  Links are unidirectional
although two links can be combined to form a bidirectional relationship
between objects.</p>
<p>Links form the graph in the object model.</p>
<p>The &lt;code&gt;**check()**&lt;/code&gt; callback is invoked when
object_property_set_link() is called and can raise an error to prevent the
link being set.  If &lt;code&gt;**check**&lt;/code&gt; is NULL, the property is read-only
and cannot be set.</p>
<p>Ownership of the pointer that <strong>child</strong> points to is transferred to the
link property.  The reference count for &lt;code&gt;***child**&lt;/code&gt; is
managed by the property from after the function returns till the
property is deleted with object_property_del().  If the
&lt;code&gt;**flags**&lt;/code&gt; &lt;code&gt;OBJ_PROP_LINK_STRONG&lt;/code&gt; bit is set,
the reference count is decremented when the property is deleted or
modified.</p>
<dl class="function">
<dt id="c.object_property_add_str">
void <code class="descname">object_property_add_str</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, char *(*get) (Object<em>&nbsp;*</em>, Error<em>&nbsp;**</em>, void (*set) (Object<em>&nbsp;*</em>, const char<em>&nbsp;*</em>, Error<em>&nbsp;**</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_str" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*(*)(Object</span> <span class="pre">*,</span> <span class="pre">Error</span> <span class="pre">**)</span> <span class="pre">get</span></code></dt>
<dd>the getter or NULL if the property is write-only.  This function must
return a string to be freed by g_free().</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(Object</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*,</span> <span class="pre">Error</span> <span class="pre">**)</span> <span class="pre">set</span></code></dt>
<dd>the setter or NULL if the property is read-only</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a string property using getters/setters.  This function will add a
property of type &#8216;string&#8217;.</p>
<dl class="function">
<dt id="c.object_property_add_bool">
void <code class="descname">object_property_add_bool</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, <a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a> (*get) (Object<em>&nbsp;*</em>, Error<em>&nbsp;**</em>, void (*set) (Object<em>&nbsp;*</em>, <a class="reference internal" href="object_interfaces.html#c.bool" title="bool">bool</a>, Error<em>&nbsp;**</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_bool" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">(*)(Object</span> <span class="pre">*,</span> <span class="pre">Error</span> <span class="pre">**)</span> <span class="pre">get</span></code></dt>
<dd>the getter or NULL if the property is write-only.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(Object</span> <span class="pre">*,</span> <span class="pre">bool,</span> <span class="pre">Error</span> <span class="pre">**)</span> <span class="pre">set</span></code></dt>
<dd>the setter or NULL if the property is read-only</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a bool property using getters/setters.  This function will add a
property of type &#8216;bool&#8217;.</p>
<dl class="function">
<dt id="c.object_property_add_enum">
void <code class="descname">object_property_add_enum</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const char *<em>&nbsp;typename</em>, const QEnumLookup *<em>&nbsp;lookup</em>, int (*get) (Object<em>&nbsp;*</em>, Error<em>&nbsp;**</em>, void (*set) (Object<em>&nbsp;*</em>, int, Error<em>&nbsp;**</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_enum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>the name of the enum data type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">QEnumLookup</span> <span class="pre">*</span> <span class="pre">lookup</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(Object</span> <span class="pre">*,</span> <span class="pre">Error</span> <span class="pre">**)</span> <span class="pre">get</span></code></dt>
<dd>the getter or <code class="docutils literal"><span class="pre">NULL</span></code> if the property is write-only.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(Object</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">Error</span> <span class="pre">**)</span> <span class="pre">set</span></code></dt>
<dd>the setter or <code class="docutils literal"><span class="pre">NULL</span></code> if the property is read-only</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an enum property using getters/setters.  This function will add a
property of type &#8216;<strong>typename</strong>&#8216;.</p>
<dl class="function">
<dt id="c.object_property_add_tm">
void <code class="descname">object_property_add_tm</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, void (*get) (Object<em>&nbsp;*</em>, struct tm<em>&nbsp;*</em>, Error<em>&nbsp;**</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_tm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(Object</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">tm</span> <span class="pre">*,</span> <span class="pre">Error</span> <span class="pre">**)</span> <span class="pre">get</span></code></dt>
<dd>the getter or NULL if the property is write-only.</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a read-only struct tm valued property using a getter function.
This function will add a property of type &#8216;struct tm&#8217;.</p>
<dl class="function">
<dt id="c.object_property_add_uint8_ptr">
void <code class="descname">object_property_add_uint8_ptr</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const uint8_t *<em>&nbsp;v</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_uint8_ptr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer to value</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an integer property in memory.  This function will add a
property of type &#8216;uint8&#8217;.</p>
<dl class="function">
<dt id="c.object_property_add_uint16_ptr">
void <code class="descname">object_property_add_uint16_ptr</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const uint16_t *<em>&nbsp;v</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_uint16_ptr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint16_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer to value</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an integer property in memory.  This function will add a
property of type &#8216;uint16&#8217;.</p>
<dl class="function">
<dt id="c.object_property_add_uint32_ptr">
void <code class="descname">object_property_add_uint32_ptr</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const uint32_t *<em>&nbsp;v</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_uint32_ptr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer to value</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an integer property in memory.  This function will add a
property of type &#8216;uint32&#8217;.</p>
<dl class="function">
<dt id="c.object_property_add_uint64_ptr">
void <code class="descname">object_property_add_uint64_ptr</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const uint64_t *<em>&nbsp;v</em>, Error **<em>&nbsp;Errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_uint64_ptr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer to value</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">Errp</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an integer property in memory.  This function will add a
property of type &#8216;uint64&#8217;.</p>
<dl class="function">
<dt id="c.object_property_add_alias">
void <code class="descname">object_property_add_alias</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Object *<em>&nbsp;target_obj</em>, const char *<em>&nbsp;target_name</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_alias" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">target_obj</span></code></dt>
<dd>the object to forward property access to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">target_name</span></code></dt>
<dd>the name of the property on the forwarded object</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an alias for a property on an object.  This function will add a property
of the same type as the forwarded property.</p>
<p>The caller must ensure that &lt;code&gt;**target_obj**&lt;/code&gt; stays alive as long as
this property exists.  In the case of a child object or an alias on the same
object this will be the case.  For aliases to other objects the caller is
responsible for taking a reference.</p>
<dl class="function">
<dt id="c.object_property_add_const_link">
void <code class="descname">object_property_add_const_link</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, Object *<em>&nbsp;target</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_add_const_link" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object to add a property to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>the object to be referred by the link</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an unmodifiable link for a property on an object.  This function will
add a property of type link&lt;TYPE&gt; where TYPE is the type of <strong>target</strong>.</p>
<p>The caller must ensure that <strong>target</strong> stays alive as long as
this property exists.  In the case <strong>target</strong> is a child of <strong>obj</strong>,
this will be the case.  Otherwise, the caller is responsible for
taking a reference.</p>
<dl class="function">
<dt id="c.object_property_set_description">
void <code class="descname">object_property_set_description</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, const char *<em>&nbsp;name</em>, const char *<em>&nbsp;description</em>, Error **<em>&nbsp;errp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_property_set_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object owning the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">description</span></code></dt>
<dd>the description of the property on the object</dd>
<dt><code class="docutils literal"><span class="pre">Error</span> <span class="pre">**</span> <span class="pre">errp</span></code></dt>
<dd>if an error occurs, a pointer to an area to store the error</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set an object property&#8217;s description.</p>
<dl class="function">
<dt id="c.object_child_foreach">
int <code class="descname">object_child_foreach</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, int (*fn) (Object<em>&nbsp;*child</em>, void<em>&nbsp;*opaque</em>, void *<em>&nbsp;opaque</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_child_foreach" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object whose children will be navigated</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(Object</span> <span class="pre">*child,</span> <span class="pre">void</span> <span class="pre">*opaque)</span> <span class="pre">fn</span></code></dt>
<dd>the iterator function to be called</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">opaque</span></code></dt>
<dd>an opaque value that will be passed to the iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <strong>fn</strong> passing each child of <strong>obj</strong> and <strong>opaque</strong> to it, until <strong>fn</strong> returns
non-zero.</p>
<p>It is forbidden to add or remove children from <strong>obj</strong> from the <strong>fn</strong>
callback.</p>
<p><strong>Return</strong></p>
<p>The last value returned by <strong>fn</strong>, or 0 if there is no child.</p>
<dl class="function">
<dt id="c.object_child_foreach_recursive">
int <code class="descname">object_child_foreach_recursive</code><span class="sig-paren">(</span>Object *<em>&nbsp;obj</em>, int (*fn) (Object<em>&nbsp;*child</em>, void<em>&nbsp;*opaque</em>, void *<em>&nbsp;opaque</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_child_foreach_recursive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the object whose children will be navigated</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(Object</span> <span class="pre">*child,</span> <span class="pre">void</span> <span class="pre">*opaque)</span> <span class="pre">fn</span></code></dt>
<dd>the iterator function to be called</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">opaque</span></code></dt>
<dd>an opaque value that will be passed to the iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <strong>fn</strong> passing each child of <strong>obj</strong> and <strong>opaque</strong> to it, until <strong>fn</strong> returns
non-zero. Calls recursively, all child nodes of <strong>obj</strong> will also be passed
all the way down to the leaf nodes of the tree. Depth first ordering.</p>
<p>It is forbidden to add or remove children from <strong>obj</strong> (or its
child nodes) from the <strong>fn</strong> callback.</p>
<p><strong>Return</strong></p>
<p>The last value returned by <strong>fn</strong>, or 0 if there is no child.</p>
<dl class="function">
<dt id="c.container_get">
Object * <code class="descname">container_get</code><span class="sig-paren">(</span>Object *<em>&nbsp;root</em>, const char *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.container_get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Object</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root of the #path, e.g., object_get_root()</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to the container</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a container object whose path is <strong>path</strong>.  Create more containers
along the path if necessary.</p>
<p><strong>Return</strong></p>
<p>the container object.</p>
<dl class="function">
<dt id="c.object_type_get_instance_size">
size_t <code class="descname">object_type_get_instance_size</code><span class="sig-paren">(</span>const char *<em>&nbsp;typename</em><span class="sig-paren">)</span><a class="headerlink" href="#c.object_type_get_instance_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">typename</span></code></dt>
<dd>Name of the Type whose instance_size is required</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the instance_size of the given <strong>typename</strong>.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">QEMU</a></h1>



<p class="blurb">Developers Guide</p>



<p>
<iframe src="https://ghbtns.com/github-btn.html?user=&repo=&type=watch&count=true&size=large"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>




<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../decodetree.html">Decodetree Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kconfig.html">QEMU and Kconfig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loads-stores.html">Load and Store APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory.html">The memory API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../migration.html">Migration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../qapi.html">QAPI headers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../qemu.html">QEMU headers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../qom.html">QOM headers</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="cpu.html">QEMU CPU header</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">QEMU Object Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="object_interfaces.html">QEMU Object Model interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="qom-qobject.html">QObject wrappers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../stable-process.html">QEMU and the stable process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../secure-coding-practices.html">Secure Coding Practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tcg.html">Translator Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing.html">Testing in QEMU</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, The QEMU Project Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>